<html>
  <title>Blog on Sketchpad14: Part VI</title>
  <head>
    <link href="./lib/prism.css" rel="stylesheet" />
    <link href="index.css" rel="stylesheet"></link>
  </head>
  </style>
<body>
  <script src="./lib/prism.js"></script>
  <script>
    function startSketchpadPlayground() {
    var iframe = document.createElement('iframe');
    iframe.id = "sketchpad-playground"    
    iframe.src = "../2d/demo/demos.html?example=polygons"
    var div = document.getElementById("sketchpad-playground-div")
    div.removeChild(div.firstChild)
    div.appendChild(iframe)
    }
  </script>
  <hd>Half-Century Later:
    <br>
    "From Sketchpad<small>61</small> to Sketchpad<small>14</small>"
    <br>
    <small>
      Part V: Creating Applications from Scratch in CRP, <br>(Remaking the "Parables of the Polygons" Demo)
    </small>
  </hd>
  <br><br>
  <small><a href="http://www.hesam.us">Hesam Samimi</a>, <a href="http://www.tinlizzie.org/~awarth">Alex Warth</a><br><a href="http://www.cdglabs.org">Communication Design Group</a></small>
  <br><br>
  <img src="img/1.png"></img>
  <br>
  <hd1>Parable of the Polygons</hd1>
  <div class="chapter">
    <p>
      Recently, CDG's <a href="http://vihart.com/">Vi Hart</a> and web programmer <a href="http://www.patreon.com/ncase">Niky Case</a> relased a highly cited and praised web page called <a href="http://ncase.me/polygons/">Parables of the Polygons</a>. Not only beautifully designed, the page explains a mathematics concept in an explorable way and leads to conveying a positive social lesson for tolerance of all. We took the task of remaking the web page in Sketchpad<small>14</small> and the CRP model to understand the advantages and limitations of our approach. This chapter summarizes what it took to make the demo.
    </p>
    <img src="img/18.png" width="150%" style="margin-left: -30%"></img>
    <p>
      Figure above is a snapshot of the demo done in Sketchpad<small>14</small>. Though this demo does not fully implement the original page, most interesting and interactive behaviors are present. Surprisingly, only three new constraint types had to be defined, two of which can be seen in the constraint list view in the figure above. The other five type of constraints were already part of our predefined set of constraints.
    </p>
  </div>
  <img src="img/1.png"></img>
  <br>
  <hd1>What's it take to program in CRP/Sketchpad<small>14</small>?</hd1>
  <div class="chapter">
    <p>
      You could find the source code for this demo at <small>"<a href="../2d/demo/polygons/example-polygons.js">../2d/demo/polygons/example-polygons.js</a>"</small> or play it at the <a href="#sketchpad-playground-div">bottom</a> of this page. Let's examine it. (It should be possible to develop it all within the tool itself, but at the moment the UI just isn't usable yet.)
    </p>
    <p>
      All CRP programs are organized in the same way. <b>Data classes</b> are defined first, then <b>constraint classes</b>. Afterwards <b>data</b> objects are created and then <b>constraints</b> are instantiated to operate on them. Finally, should this be an interactive program (all Sketchpad<small>14</small> are because objects are draggable), <b>events</b> are registered, whose job is to modify the data and constraint stores.
    </p>
  </div>
  <img src="img/1.png"></img>
  <br>
  <hd1>Data Classes</hd1>
  <div class="chapter">
    <img src="../2d/demo/polygons/img/yay_triangle.png" onmouseover="this.src='../2d/demo/polygons/img/yay_triangle_blink.png'" onmouseout="this.src='../2d/demo/polygons/img/yay_triangle.png'" style="margin-left: 45%"></img>
    <ul>
      <li>
	<mono>Shape (Position position, Number kind, Number mood, Image image, Board board, Vector boardPos)</mono>
	  <p>
	    denotes each polygon shape in the page. <mono>kind</mono> is 1 for <i>squares</i> and 2 for <i>triangles</i>. <mono>mood</mono> is -1 for <i>sad</i>, 0 for <i>meh</i>, and 1 for <i>yay</i>. When shape is part of a board, properties <mono>board</mono> and <mono>boardPos</mono> are set. The latter tells the board coordinates at which the shape is placed.
	  </p>
	  <p>
	    Note that each data class, such as this one, has defined a <mono>draw</mono> method that is responsible for drawing the object on the shared canvas.
	  </p>
	</li>
      </ul>
    <ul>
      <li>
	<mono>Board (Position position, Number cols, Number rows, Number cellLength, Shape[] cells, Number kindPercentage)</mono>
	  <p>
	    denotes each board in the page. <mono>cells</mono> is an array representing what's on it, whose elements may be <mono>Shape</mono>s or none. Board elements will be indexed by <i>(row# * cols + col#)</i> encoding. <mono>kindPercentage</mono> is the ratio of the count of sorrounding kind shapes to all sourrounding shapes, which is the threshold below which the shape will feel <i>sad</i> and inclined to move.
	  </p>
	  <p>
	    We will see later than one the constraint types will be affecting the <mono>cells</mono> array property of a board. Clearly the default solution join function (<mono>dampedAverageJoin</mono> seens in the <a href="4.html">previous part</a>) does not work on non-real values and hence unsuitable here. Instead, the class uses a different join function called <mono>dictionaryAddJoin</mono>:
	  </p>
	  <pre><code class="language-javascript">
// Dictionary add join fn:
dictionaryAddJoin = function(curr, solutions) {
    solutions.forEach(function(v) { for (var k in v) curr[k] = v[k] })
    return curr
}
	  </code></pre>
	<p>
	  where each solution is a dictionary of key/value pairs that include keys (in this case indices in an array) that it wants to change. So, here is how the class defines its <mono>solutionJoins</mono> function:
	</p>
	  <pre><code class="language-javascript">
Board.prototype.solutionJoins = function() { 
    return {cells: dictionaryAddJoinSolutions}
}
	</code></pre>
	  <p>
	    Now the reason the above works is that we happen to know there will be exactly one solution and no chance of conflicts, because there will be exactly one constraint that will want to set the <mono>cells</mono> property of a board at a given time. This will become obvious later when we see how constraints are set up.
	  </p>
	  <p>
	    This class also has a few important functions related to the logic of the game, implemented in JS code:
	  </p>
	    <ul>
	      <li>
		<mono>fits(Vector pos)</mono> returns whether or not the board based on its current placements can fit a new piece in coordinates <mono>pos</mono>.
	      </li>
	      <li>
		<mono>getCoord(Point position)</mono> determines whether or not a <mono>position</mono> on the canvas falls in one of the cells of the board, and if so it computes the associated coordinates.
	      </li>
	      <li>
		<mono>getEmptyCoord()</mono> returns a random empty cell coodinate, should there one exist.
	      </li>
	      <li>
		<mono>getMood(Shape shape)</mono> returns the mood of a shape (i.e., -1, 0, or 1) depending on its sourrounding cells.  
	      </li>
	      <li>
		<mono>firstSadShape()</mono> returns the first sad shape (moving from top-left to botton-right corner) on the board.
	      </li>
	    </ul>
	</li>
      </ul>
  </div>
  <img src="img/1.png"></img>
  <br>
  <hd1>Constraint Classes</hd1>
  <div class="chapter">
    <img src="img/20.png" style="margin-left: 45%"></img>
    <ul>
      <li>
	<mono>ShapeSwingConstraint (Shape shape, Number swingSpeed, Boolean dangling)</mono>
	  <p>
	    states that <mono>shape</mono> must swing back and forth over a span of 36 degrees, at a rate of <mono>swingSpeed</mono>. We will see later how <mono>dangling</mono> boolean flag is used.
	  </p>
	<p>
	  So let's go over the functions that must be defined for a constraint type:
	</p>
	<ul>
	  <li>
	    <p>Definitions related to property type checking and summary generation:</p>
	    <pre style="margin-left: -100px;"><code class="language-javascript">
// property types:
ShapeSwingConstraint.prototype.propertyTypes =
    {shape: 'Shape', swingSpeed: 'Number', dangling: 'Boolean'}

// class summary:
ShapeSwingConstraint.description = function() {
    return "ShapeSwingConstraint(Shape S, Number R, Boolean D) causes image of S to swing at rate R. When D is true this is simulating dangling and will gadually subside."
} 

// instance-specific summary:
ShapeSwingConstraint.prototype.description = function() {
    return  "image of shape" + this.shape
        + " should " + (this.dangle ? "dangle" : "swing") + " at an initial rate of " + this.swingSpeed
}
	    </code></pre>
	  </li>
	  <li>
	    <p>And now things related to constraint solving:</p>
	    <pre style="margin-left: -100px;"><code class="language-javascript">
ShapeSwingConstraint.prototype.computeError = function(pseudoTime) {
    this.targetRotation = this.image.origRotation
        + (Math.sin(this.image.swingSpeed * pseudoTime + this.rotationOffset)
               * Math.PI / 10)
    return this.targetRotation - this.image.rotation
}

ShapeSwingConstraint.prototype.solve = function(pseudoTime) {
    return {image: {rotation: this.targetRotation}}
}
	    </code></pre>
	  </li>	  
	  <br>  
      <li>
	<mono>TimerConstraint (Timer timer)</mono>
	<p>
	  Note that the previous constraint was temporal, i.e., it's a function of time, or as we have here: <mono>pseudoTime</mono>. In order for the system pseudo time to advance, the user must add a <mono>TimerConstraint</mono>. It simply tells the system that it should update the <mono>pseudoTime</mono> to reflect the time passed since last evaluation cycle (see <a href="4.html">Part IV</a>).
	  </p>
      </li>	  
      <br>  
      <li>
	<mono>ShapeMoodConstraint (Shape shape)</mono>
	  <p>
	    states that the URL of the image belonging to the <mono>shape</mono> must reflect its <mono>mood</mono> property, which must be set based on the sorrounding shapes.
	  </p>
	<p>
	  We'll skip the functions related to type checking and summary generation, as they are similar to the previous constraint. So let's go over the constraint solving parts:
	</p>
	<ul>
	  <li>
	    <p><mono>computeError</mono> function:</p>
	    <pre style="margin-left: -100px;"><code class="language-javascript">
ShapeMoodConstraint.prototype.computeError = function(pseudoTime) {
    this.targetMood = this.shape.getMood()
    return (shape.mood ==  this.targetMood
      && this.shapeImage.url === this.shape.getUrl(this.targetMood)) ? 0 : 1
}
	    </code></pre>
	  </li>
	  <li>
	    <p><mono>solve</mono> function: </p>
	    <pre style="margin-left: -100px;"><code class="language-javascript">
ShapeMoodConstraint.prototype.solve = function(pseudoTime) {
    return {shape: {mood: this.targetMood},
            shapeImage: {url: this.shape.getUrl(this.targetMood)}}
}
	    </code></pre>
	  </li>	  
	  <br>  
	  <li>
	    <mono>ShapePlacementConstraint (Shape shape)</mono>
	    <table>
	      <tr>
		<td><img src="img/21.gif" class="clicktoplay" data-staticSrc="img/21s.png" style="margin-left: 60%"></img></td>
		<td><p class="side" style="margin-left: 100%">Behavior of <mono>ShapePlacementConstraint</mono></p></td>
	      </tr>
	    </table>	    
	  <p>
	    states if <mono>shape</mono> is moved inside the its board and it fits in the dropped coordinate, it should snap in place in the center and its board should add it in in the right index of its <mono>cells</mono> array. Otherwise it should snap back in its original position. As we will see, we only add this constraint when a shaped is picked up to be dragged. Once another shape is picked up, this constraint is no longer necessary (must have already snapped in the right place) and we'll remove the constraint.
	  </p>
	<p>
	  So let's go over the functions that must be defined for a constraint type:
	</p>
	<ul>
	  <li>
	    <p><mono>computeError</mono>: We check if the position of shape is within the board and if the board coordinate closest to the shape's position is free. If so, we compute the position where the shape should be snaped into. Otherwise, it should snap back at its original place on the board (<mono>this.shapeOrigPos</mono>). We store the target position in <mono>this.targetPos</mono> to avoid recomputation in the <mono>solve<mono> function. The error value is the distance between the current position of the shape and its computed target position:</p>
	    <pre style="margin-left: -100px;"><code class="language-javascript">
ShapePlacementConstraint.prototype.computeError = function(pseudoTime) {
    var shapeCurrPos = this.shapePos, board = this.board
    this.shapeCoord = board.getCoord(shapeCurrPos)
    var inside = board.containsPoint(shapeCurrPos)
    if (inside && board.fits(shapeCoord)) {
        this.placing = true
        this.targetPos = plus(board.position,
            {x: shapeCoord.j * board.cellLength,
             y: shapeCoord.i * board.cellLength})
    } else {
        this.placing = false
        this.targetPos = this.shapeOrigPos
    }
    return magnitude(minus(this.targetPos, shapeCurrPos))
}
	    </code></pre>
	    </li>
	  <li>
	    <p><mono>solve</mono>: We have already computed where the position of shape must be updated to and stored it in <mono>this.targetPos</mono>. If we the shape is being placed on the board (captured by boolean value <mono>this.placing</mono>) then the solution wants to free up the previous cell location and set the content of the new cell coordinates to this shape. This is done by setting the respecitve location in the <mono>cells</mono> array to 0 or the <mono>shape</mono>, respectively:
	    <pre style="margin-left: -100px;"><code class="language-javascript">
ShapePlacementConstraint.prototype.solve = function(pseudoTime) {
    var board = this.board, shape = this.shape
    var sol = {shapePos: {x: this.targetPos.x, y: this.targetPos.y}}
    if (this.placing) {
        var shapeOldCoord = shape.boardPos
        var dict = {}
        dict[(shapeOldCoord.i * board.width) + shapeOldCoord.j] = 0
        dict[(this.shapeCoord.i * board.width) + this.shapeCoord.j] = shape
        sol.board = {cells: dict}
        sol.shapeBoardPos = {i: this.shapeCoord.i, j: this.shapeCoord.j}
    }
    return sol
}
	    </code></pre>
	  </li>
	</ul>
  </div>
  <img src="img/1.png"></img>
  <br>
  <hd1>Reactive Parts</hd1>
  <div class="chapter">
  <img src="img/22.png" style="margin-left: 42%"></img>
    <p>
      Now that we have all the constraint types we need, we can worry about the interactive/reactive part of the demo.
    </p>
    <ul>
      <li>
	Dragging pieces (<mono>CoodinateConstraint</mono> on <mono>mouse</mono> events):
	<p>
	  As with all demos, the default dragging-related events allowing things to be moved are in place. We saw these in <a href="3.html">Part III</a>.
	</p>
      </li>
      <li>
	Placing pieces on a board (<mono>ShapePlacementConstraint</mono> on <mono>mouse</mono> events):
	<p>
	  We could have this constraint be a continuous requirement on all pieces that are part of a board. However, since it applies only when a piece that was picked up dropped by the user, it makes sense to only add this requirement then and remove it the next time another piece is picked up (since by that time that original piece is already placed nicely in place).
	</p>
	<pre><code class="language-javascript">

registerEvent('mouseup', function(e) {
    var thing = e.pointedObject
    if (thing !== undefined && thing instanceof Shape
           && thing.board !== undefined)
        placementConstraint = addConstraint(
            new ShapePlacementConstraint(thing))
})
    </code></pre>
	<pre><code class="language-javascript">

registerEvent('mousedown', function(e) {
    if (placementConstraint !== undefined) {
        removeConstraint(placementConstraint)
        placementConstraint = undefined
    }
})
    </code></pre>
      </li>
      <li>
	Swinging faster on mouse hover (<mono>ShapeSwingConstraint</mono> on <mono>mouse</mono> events):
	<p>
	  The pieces on the header of the page (stored in the <mono>swingingShapes</mono> array) swing faster when mouse hovers over them. They all already have a <mono>ShapeSwingConstraint</mono> operating over them, so it's simply a matter of changing the property of that constraint to reflect the speeding or slowing of the swing rate:
	</p>
	<pre><code class="language-javascript">
	    
registerEvent('mousemove', function(e) {
    swingingShapes.forEach(function(shape) {
        var dist = distance(e.mousePosition, shape.position)
        shape.swingConstraint.swingSpeed =
            2 + (dist < 200 ?  ((200-dist)/200*10) : 0)
    }
})
    </code></pre>
      </li>
      <li>
	Pieces dangle when dragged (also using <mono>ShapeSwingConstraint</mono> on <mono>mouse</mono> events):
	<table>
	  <tr>
	    <td><img src="img/23.gif" class="clicktoplay" data-staticSrc="img/23s.png" style="margin-left: 100%"></img></td>
	    <td><p class="side" style="margin-left: 120%">Dangling effect</p></td>
	  </tr>
	</table>	    
	<p>
	  We'll add an instance of <mono>ShapeSwingConstraint</mono> to not only the happy swinging shapes on the page header, but also to a shape that is picked up by the user (to get a <i>dangling</i> effect). The difference is that the dangling kind's swing rate subsides with passage of time. 
	</p>
	<p>
	  There is a feature we haven't talked about before, but we'll now disuccs and use it. Each class (be it a data or constraint type) can define a <mono>onEachTimeStep</mono> method, which will be run by the CRP execution model right before going to the <i>solving stage</i>, and is used to do any sort of housekeeping, propertying updating, etc.
	</p>
	<p>
	  Thus we define a <mono>onEachTimeStep</mono> for each instance of the <mono>ShapeSwingConstraint</mono> which happens to be simulating dangling, to get the effect of gradually damping and turning off the dangling speed:
	</p>
	<pre><code class="language-javascript">
ShapeSwingConstraint.prototype.onEachTimeStep = function(pseudoTime) {
    if (this.dangle) {
	var movement = this.shape.position.x - this.shap.lastPosition.x
	if (Math.abs(movement) > 0)
	      this.swingSpeed += (movement / 200)
	else {
	    this.swingSpeed /= 1.05
	    if (this.image.swingSpeed < 0.001)
		this.swingSpeed = 0
	}
	this.shape.lastPosition = this.shape.position.copy()
    }
}	    
    </code></pre>
	<p>
	  Now all we need to do to get dangling working is to add a <mono>ShapeSwingConstraint</mono> when a shape is picked up:
	</p>
	<pre><code class="language-javascript">
registerEvent('mousedown', function(e) {
    var thing = e.pointedObject
    if (thing !== undefined && thing instanceof Shape) {
        danglingConstraint = addConstraint(
            new ShapeSwingConstraint(thing, 2, true))
    }
})
	</code></pre>
	<p>Similarly, the constraint gets removed when a shape is dropped down.</p>
      </li>
    </ul>
  </div>
  <img src="img/1.png"></img>
  <br>
  <hd1>Final Step:<br>Laying out data and constraints</hd1>
  <div class="chapter">
    <p>
      By now all kinds of data, and continuous and reactive behaviors have been defined. All that's left to do is layout the page and add constraints.
    </p>
    <p>
      To get the temporal constraints going, don't forget to add a <mono>TimerConstraint</mono> so that the system's clock gets ticking:
    </p>
    <pre><code class="language-javascript">
	addConstraint(new TimerConstraint(new Timer(1))) // steps pseudo-time by 1 unit at each frame
    </code></pre>
    <p>Now we'll instantiate as many <mono>Shape</mono>s, <mono>Board</mono>s, <mono>TextBox</mono>es, etc. as we need, and add constraints as appropriate.
    </p>
    <p>
      That's all folks. We omitted some parts of the demo (e.g., In the tool see the <a href="../2d/demo/example-slider.js">slider</a> demo, which was implemented separately and reused here), but you should have gotten a good overview of things by now!
    </p>
  </div>
  <img src="img/1.png"></img>
  <br>
  <p>
    Read <a href="6.html">Part VI: Comparison of CRP and Imperative Programming</a><br>
    Back to <a href="index.html">Table of Contents</a><br>
  </p>
  <img src="img/1.png"></img>
  <br>
  <hd1>Click to view this demo!</hd1>
  <br>
  <br>
  <div id="sketchpad-playground-div"><img src="img/19.png" onclick="startSketchpadPlayground()" style="margin-left: -5%"></img></div>    
  <script src="./lib/click-to-play-gif.js"></script>
</body>
</html>
