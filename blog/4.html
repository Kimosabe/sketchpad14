<html>
  <title>Blog on Sketchpad14: Part IV</title>
  <head>
    <link href="./lib/prism.css" rel="stylesheet" />
    <link href="index.css" rel="stylesheet"></link>
  </head>
  </style>
<body>
  <script src="./lib/prism.js"></script>
  <hd>Back to a Half-Century Later:
    <br>
    "From Sketchpad<u>61</u> to Sketchpad<u>14</u>"
    <br>
    <small>
      Part IV: Execution Model in CDP
    </small>
  </hd>
  <br><br>
  <small><a href="http://www.hesam.us">Hesam Samimi</a>, <a href="http://www.tinlizzie.org/~awarth">Alex Warth</a><br><a href="http://www.cdglabs.org">Communications Design Group</a></small>
  <br><br>
  <img src="img/1.png"></img>
  <br>
  <hd1>Constraint Solving in Sketchpad14</hd1>
  <div class="chapter">
    <p>
      As we saw in the overview of the Overveld approach, each individual constraint has provided the appropriate methods to measure the current error based on the current state, expressed in terms of a set of <i>deltas</i> on variables. Thus a single function (recall we called it <mono>computeDeltas</mono>) is used to both <i>state</i> and <i>solve</i> the constraint.
    </p>
    <p>
      In CDP, we separate the function that defines the constraint and the one that solves it. Constraint is stated here using a function here called <mono>computeError</mono>, which still expresses the constraint as a numerical error from a solution that fully satisfies it. Another function named <mono>solve</mono> is used to return a set of <i>patches</i> on variables, i.e., a set of new values for those variables in the program state it would like to change in order to become satisfied. Let's discuss these in more detail.
    </p>
  </div>
    <img src="img/1.png"></img>
  <br>
  <hd1>Required Functions for Constraint and Data Classes</hd1>
  <div class="chapter">
    <p>
      All the predefined constraints implement a few standard methods, and if the user wants to define a new constraint type they must be implemented as well. For constraint types the most important variables and methods are (shown on the top when browsing the class):
    </p>
    <ul>
      <li>
	<mono>propertyTypes</mono>: gives a type to the properties, enabling type-checking UI features.	
      </li>
      <br>
      <li>
	<mono>computeError</mono>: is a function that given the current <i>pseudo-time</i> of the system (some constraints are temporal) as well as the state of the properties of the constraints, returns a numeric <i>error</i> value as an indicator for how close the state is from a solution. A constraint is assumed satisfied when it returns an error value less than <mono>epsilon</mono>, a parameter of the system.
      </li>
      <br>	    
      <li>
	<mono>solve</mono>: which the system calls once it deems the constraint unsatisfied. This function returns a dictionary object as a solution to the constraint. This solution is essentially interpreted as a set of <i>patches</i> to the current state, indicating the set of variables that need to be changed and the values they need to be changed to. The set of patches are organized as a dictionary where the keys are the names of the property objects belonging to the constraint (e.g., in the <mono>FixedLength</mono> they are called <mono>p1</mono>  and  <mono>p2</mono>) and the values are themselves dictionaries, mapping the name of a property belonging to an object to a new value. 
      </li>
    </ul>
    <p>
      Here is how these properties are defined for an instance of <mono>FixedLength</mono> (note that auxiliary functions <mono>plus</mono>, <mono>normalized</mono>, etc. operate over and return <mono>Point</mono> types, which are themselves essentially dictionary objects with <mono>x</mono> and <mono>y</mono> keys):
    </p>
    <pre><code class="language-javascript">
	// propertyTypes:
	FixedLength.prototype.propertyTypes =
	    {p1: 'Point', p2: 'Point', l: 'Number'}

	// computeError:
	FixedLength.prototype.computeError = function(pseudoTime) {
	    return distance(this.p1, this.p2) - this.l
	}

	// solve:
	FixedLength.prototype.solve = function(pseudoTime) {
	    var p1 = this.p1, p2 = this.p2
	    var delta = (distance(p1, p2) - this.l) / 2
	    var e12 = scaledBy(normalized(minus(p2, p1)), delta)
	    var res = {p1: plus(p1, e12), p2: plus(p2, scaledBy(e12, -1))}
	    return res
	}	
    </code></pre>
    <p>
      Contrast the above with the <mono>computeDeltas</mono> function for the <mono>FixedLength</mono> in the Overveld approach, given previously. In Overveld way the solution was a set of deltas, but here the solution is the set of new values the constraint is proposing on the two points' coordinates. It so happens that these new values are obtained by computing delta values and adding to the current values. What's important is that this was left a choice to the implementer of the constraint type, rather than the system assuming so. We elaborate on this next.
    </p>
    <p>
      How are individual solutions consolidated in the presence of multiple constraints? CDP employs the approach of Overveld (see <a href="1.html">Part I</a>) to collect the solutions from unsatisfied constraints and <i>merge</i> them in order to come up with a <i>single consolidated solution</i>. Unlike the Overveld approach, however, where the merging is always simply <i>averaging</i> numeric values per variable, CDP generalizes this and allows the user to define a <mono>solutionMerge</mono> function per class property that decides how multiple solutions are combined. 
    </p>
    <p>
      This generality is essential to accommodate numerous scenarios that arise in program development. Firstly, we cannot assume the patches proposed by the constraint are numeric real values, as they might be on finite data types, etc. Secondly, the right way to combine two competing solutions from two individual constraints maybe to raise a conflict and stop, prefer one to other because of priorities, or even apply some custom merge function not at all captured by averaging the values. We'll see examples later.
    </p>
    <p>
      This leads us to a place where we need to review the important methods that data classes must define:
    </p>
    <ul>
      <li>
	<mono>merge</mono>: Given the current value (<mono>curr</mono>) of each class property (a.k.a., instance variable) and the set of collected new values from constraints that have proposed to update it (<mono>solutions</mono>), this function decides how to combine the solutions to determine the new value for the variable. For example, to perform the Overveld style averaging and damping the deltas (happens to be the <i>default</i> merge function for all variables) we can define the following:
	<pre><code class="language-javascript">
	// Overveld relaxation style (damped avg) (default) solution merge fn:
	dampedAverageMergeFn = function(curr, solutions) {
	    var damping = 0.25
	    var sum = 0
	    solutions.forEach(function(v) { sum += v })
	    var avg = sum / solutions.length
	    return curr + (damping * (avg - curr))
	}
</code></pre>
	For non-real values the above merging function does not make sense. In the simple case where we know there is exactly one constraint acting on a variable, we can simply return that single solution (or pick a random choice among multiple ones):
	<pre><code class="language-javascript">
	// Pick a solution merge fn:
	pickOneMergeFn = function(curr, solutions) {
	    return solutions[0]
	}
</code></pre>
	For example, the <mono>Point</mono> class with properties <mono>x, y: Number</mono>  and <mono>color: String</mono>, lets the <mono>x</mono> and <mono>y</mono> properties use the default solution merge function (<mono>dampedAverageMergeFn</mono>), yet overwrites the function for its <mono>color</mono> property:
	<pre><code class="language-javascript">
	Point.prototype.merge = function() { 
	    return {x: dampedAverageMergeFn,
	            y: dampedAverageMergeFn,
	            color: pickOneMergeFn}
	}
</code></pre>
	In reality, <mono>solutions</mono> also has a reference to the constraint responsible for producing each solution, thus if this function chooses to distinguish solutions based on constraint priorities, etc. it may do so. The default procedure, however, is that the system automatically sorts the collected solutions per variable and if there is a mismatch in priorities, only solutions from top priority constraints are counted.
      </li>
      <br>
      <li>
	<mono>draw</mono>: This method uses HTML canvas to define how the object should be displayed on the screen. The system redraws the entire scene at a certain rate, e.g. at 65 frames per second.
      </li>
    </ul>
    <p>
      So how is this information used? Let's see how constraint solving is done in the CDP model which this tool implements. 
    </p>
  </div>
    <img src="img/1.png"></img>
  <br>
  <hd1>State Model</hd1>
  <div class="chapter">
    <p>
      There are three main stores that are maintained by the model: (a) <b>data</b>, (b) <b>constraint</b>, and (c) <b>event</b> store. These stores get populated and modified by user operations of instantiating or removing data and constraints or registering events handlers. During the execution of the program, the stores might be modified as part of solving for various constraints or running event handlers. Figure below illustrates a possible configuration of the stores during the execution of the logo example in the <a href="3.html">previous part</a>.
    </p>
    <table>
      <tr>
	<td><img  class="chapter" src="img/15.png" style="width: 200%" style="margin-left: 15%"></img></td>
	<td><p class="side" style="margin-left: 100%; margin-top: -2%">State Model</p></td>
      </tr>
    </table>
  </div>
    <img src="img/1.png"></img>
  <br>
  <hd1>Execution Model</hd1>
  <div class="chapter">
    <p>
In order to support responsive interactive and animated programs, we adopt a two-phased execution model, cycling at an adjustable <i>frame rate</i>, e.g., 1/65 of a second. The clock time at the moment of each arrival on the first phase is used as the <i>pseudo-time</i> for the system. The two phases are: (A) <b>event handling</b> phase and (B) <b>solving</b> phase. The model is depicted in the figure below, which we'll explain next.
    </p>
    <table>
      <tr>
	<td><img class="chapter" src="img/17.png" style="width: 175%; margin-left: 15%"></img></td>
	<td><p class="side" style="margin-left: 100%; margin-top: -2%">Two-phase execution model in CDP <br>(A/D: add/delete,<br>R/W: read/write)</p></td>
      </tr>
    </table>    
    </p>
<b>(A) Event Handling Phase</b>
    <p>
      The system starts in this phase, at top of which the system is considered to be at a "good" state and the current state is drawn on the canvas (should changes have occurred). The <b>rendering</b> step calls the <mono>draw</mono> methods for all objects to refresh the frame. At this time the system updates its pseudo-time to reflect the time passed since last cycle. The handlers for any cached events that may have occurred during the previous (<i>B</i>) phase are executed next. During such step the data and constraint stores may be modified. As a result, or despite of the fact, some constraints in the constraint store may have been unsatisfied. In any case, once all relevant handlers are executed, the system moves onto the phase <i>B</i>.
      </p>
    <b>(B) Solving Phase</b>
    <p>
      During the solving phase <i>B</i> (illustrated in figure below) the system invokes the <mono>computeError</mono> function belonging to each of the existing constraints. As long as the value is more than a an <mono>epsilon</mono> error threshold (specified by the user), the system invokes the <mono>solve</mono> function associated with each unsatisfied constraint. Each solution returned by each such function is organized as a dictionary of dictionaries, mapping each object's each property to a proposed value. Thus the value returned by a <mono>solve</mono> function could be interpreted as a <i>patch</i>: a subset of the current state that the constraint would like to change indicating the proposed new values.
    </p>
    <p>
      At this point the system uses the designated <i>merge</i> function to combine all solutions to each variable into one consolidated new value, and then applies it to the variable. However, since these values aren't exactly what each constraint had asked for, after this step all or some of the previously unhappy constraints are likely to remain unhappy (or even previously happy constraints may have now turned unhappy). This is were the <i>iterative relaxation</i>  approach comes in. As long as that is the case, the system repeats the process above, until either:
    </p>
    <ul>
      <li>
	(1) no unsatisfied constraints (computed error of larger than <mono>epsilon</mono>) remain.
      </li>
      <li>
	(2) the sum total error from all constraints remains unchanged for several consecutive iterations (reached a <i>fixed-point</i>).
      </li>
      <li>
	(3) phase <i>B</i> times out, that is, the system has remained in the solving phase for longer than the frame rate value.
      </li>
    </ul>
<p>
  At that point, the model cycles back to the reactive phase <i>A</i>, and this process repeats. 
</p>
<table>
  <tr>
    <td><img  class="chapter" src="img/16.png" style="width:200%"></img></td>
    <td><p class="side" style="margin-left: 100%">Solving phase</p></td>
  </tr>
</table>	
</div>
<img src="img/1.png"></img>
<br>
<hd1>Enabling Backtracking Search</hd1>
<div class="chapter">
  <p>
    Classical <i>backtracking search</i> isn't accommodated by the CDP model as described. However, we have made a modification that allows programmers to rely on search as part of a program (see the <i>pentominoes</i> and <i>send money</i> demos). 
  </p>
  <p>   
    We let a constraint type to be marked as <mono>searchable</mono>. A searchable constraint's <mono>solve</mono> function returns a set of solutions rather than one. Thus a user can communicate to the system that it wants to try either one of the solutions and search for the right combination of solutions from all constraints that will result in a globally acceptable solution.
  </p>
  <p>
    During the first iteration of the solving phase (<i>B</i>), the system collects the set of solutions from each searchable constraint, as well as the usual one solution from others. It then constructs a search tree that gives all possible combinations of choosing a single solution from each constraint. (When no searchable constraint exists this tree has a single branch as the only combination to explore.) At this point the system engages in a traditional backtracking search to find the combination that leads to a satisfiable place. For each combination choice, it does the usual relaxing-style iterative solving up to some timeout duration, except that searchable constraints do not participate during those iterations. Should a fixed-point be reached with all constraints satisfied, the solution is committed and the model cycles back to the reactive phase <i>A</i>. Otherwise, solutions in the last attempt are discarded and the search of all possible combinations continues on.
  </p>
  <p>
    As a simple example, below we have defined a <mono>NumListSortConstraint</mono> that ensures a number list is sorted. Provided that a copy of the list is kept in <mono>scratch.oldList</mono>, the <mono>computeError</mono> function returns a 0 error only when list has been properly sorted. The <mono>solve</mono> function simply returns all possible permutations of the list, therefore hinting to the system to search for one that would make the constraint satisfied. 
  </p>
  <pre><code class="language-javascript">
NumListSortConstraint.prototype.searchable = true

NumListSortConstraint.prototype.computeError = function(pseudoTime) {
    return sorted(this.list)
        && isPermutationOf(this.list, scratch.oldList) ? 0 : 1
}

NumListSortConstraint.prototype.solve = function(pseudoTime) {
    return allPermutations(this.list).map(function (l) { return {list: l} })
}
</code></pre>
  <p>
    Note that the above scheme works well when the numeric constraints solved by relaxation and finite domain constraints solved by search are mixed together within the same program, provided that numeric constraints use searched-over values in a read-only manner. Roughly speaking, if the relaxation-style iterative approach is like <i>hill-climbing</i> in some neighborhood in the state space, our augmented search-model is akin to simultaneously running hill-climbing in different regions in space in order to have a better chance of finding a solution. We're unclear as to whether the mixing makes sense if both kinds of constraints are trying to affect the same variables.
  </p>
</div>
<img src="img/1.png"></img>
<br>
<p>
  Read <a href="5.html">Part V: Creating Applications from Scratch in CDP (Remaking the "Parables of the Polygons" Demo)</a><br>
    Back to <a href="index.html">Table of Contents</a><br>
  </p>
  <script src="./lib/click-to-play-gif.js"></script>
</body>
</html>
