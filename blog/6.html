<html>
  <title>Blog on Sketchpad14: Part VI</title>
  <head>
    <link href="./lib/prism.css" rel="stylesheet" />
    <link href="index.css" rel="stylesheet"></link>
  </head>
  </style>
<body>
  <script src="./lib/prism.js"></script>
  <hd>Half-Century Later:
    <br>
    "From Sketchpad<small><u>61</u></small> to Sketchpad<small><u>14</u></small>"
    <br>
    <small>
      Part VI: Comparison of CRP and Imperative Programming
    </small>
  </hd>
  <br><br>
  <small><a href="http://www.hesam.us">Hesam Samimi</a>, <a href="http://www.tinlizzie.org/~awarth">Alex Warth</a><br><a href="http://www.cdglabs.org">Communication Design Group</a></small>
  <br><br>
  <img src="img/1.png"></img>
  <br>
  <hd1>Advantages</hd1>
  <div class="chapter">
    <p>
      In this section we'll compare the imperative programming (IP) and constraint reactive programming (CRP) models by reflecting on the implementation in both models of a few programs, including the "Parable of the Polygons" discussed in the <a href="5.html">previous part</a>. Let's start with positives!
    </p>
    <ul>
      <li>
	<i><b>In IP behavior can be buried in piles of code; not in CRP.</b></i>
	<p>
	  IP doesn't enforce any particular restraint on programmer's thought process or program organization. He is free to write any code as long as it captures the desired behaviors. Yet the resulting code, although functional, is often cryptic and mixes behaviors in a way that's hard to parse and organize to human mind. Moreover, there is no easy way to explore and understand the program by shallow inspection due to lack of any per-behavior organization.
	</p>
	<p>
	  Take the <a href="http://ncase.me/polygons/play/automatic/automatic2.html">slider</a> in the <a href="http://ncase.me/polygons/">Parables of the Polygons</a> page, which is used to set the bias level of a shape. Where is the piece of code that's responsible for making such functionality?
	</p>
	<p>
	After digging into this, we see that the part of the page that includes the slider actually is embedded as an <i>iframe</i>, which loads the html file "play/automatic/automatic2.html." There we can see that there is an <i>event listener</i> setting the associated global variable representing bias to the value of the slider:
	</p>
	  <pre><code class="language-javascript">	  
	  onChange:function(values){	
	      window.BIAS = values[0];
	      // ...
	      bias_text.innerHTML = Math.round(window.BIAS*100)+"%";
	  }
	  </code></pre>
	<p>
	  Now we have identified the code responsible for this behavior. But there was no indication anywhere. After all, these are just lines of code like many other thousands of lines of code in this application.
	</p>
	<p>
	  The CRP model, however, would have forced the programmer to express this behavior as a constraint type. The slider behavior will indeed clearly show up in the list of constraints as an enabled behavior in the scene. In fact, as we have seen Sketchpad<small>14</small> allows to turn constraints on and off to explore the behaviors acting on the program. Here we clearly see the <mono>SliderValueConstraint</mono> in the list, can hover over the instance to see the objects it's applied to, and can temporarily disable the constraint to verify the behavior:
	</p>
	<table>
	  <tr>
	    <td><img src="img/24.gif" class="clicktoplay" data-staticSrc="img/24s.png" style="margin-left: 10%"></img></td>
	    <td><p class="side" style="margin-left: 40%">Exploring the slider behavior</td>
	  </tr>
	</table>
	<p>
	  Also note that, despite being an elaborate demo, the set of behavior types are relatively short (7-8) as we see in the graphic above. This can be contrasted to many hundreds and thousands of "lines of code" which make an imperative program.
	</p>
      </li>
      <li>
	<i><b>CRP induces a "linear" thinking process in designing, implementing, and exploring programs; IP results in "ad hoc" way of doing those.</b></i>
	<p>
	  CRP model forces the programmer to think and design the program as a set of individual behaviors. Once the set of behaviors are defined (as constraint types), building a program is simply a matter applying a selection of them to the data. Again, the list of behaviors is clearly acknowledged and alternation of behaviors can be done by selecting and mixing and matching.	  
	</p>
	<p>
	  By contrast, in IP the process is quite ad hoc. The programmer keeps a mental list of things that needs to be done for the program. She then proceeds to write the "code" that implements those things. In the lack of any organization or guidelines, this code often makes no attempt to keep the behaviors separable and modularized. It may try to use the same "loop" construct to achieve goals A and B at the same time, etc. The lack of direction and organization can also confuse the thinking process itself, leading to bugs. Although the final outcome succeeds in achieving all desired behaviors, it too often fails to be amenable to extensions or facilitating understanding. In CRP, extension and modifying is a matter of reshuffling set of constraints, whereas in IP often algorithms need to be reworked.
	  </p>
      </li>
      <li>
	<i><b>CRP model reduces the possibility of bugs.</b></i>
	<p>
	  In the CRP model, all constraints act on the same state in parallel, assuming each one is the only one trying to make a change. There is a separate later process that consolidates those changes into one final result. In IP, however, the same code is used to implement multiple behaviors. Therefore, each snippet of code that aims to achieve a particular behavior sees a different state, as our programs run sequentially. This complicates human reasoning and increases the chance of introducing bugs.
	</p>
      </li>
      <li>
	<i><b>CRP frees the programmer from having to reason globally and computing or describing "emerging behaviors."</b></i>
	<p>
	  Have a look at the truss bridge demo shown below, an original Sketchpad and ThingLab demo and remade here using Sketchpad<small>14</small>. As you can see the resulting "emergent behavior" of the program is quite elaborate! There is not an easy way to "code" the behavior of this bridge under the forces of gravity and wind imperatively. On the other hand, as you can see on the constraint listing on the right pane, the constraint types that make up this overall behavior are not complicated at all. We only had to define velocity and acceleration behaviors as well as the spring force (Hook's law). Thus the programmer only has to reason "locally" and in "isolation" about each constraint. Next, we simply had to instantiate these constraints for all the bodies and beams (springs) that make up the bridge. It is the job of the system to capture the "global" behavior by combining the results of individual local constraints. 
	</p>
	<table>
	  <tr>
	    <td><img src="img/25.gif" class="clicktoplay" data-staticSrc="img/25s.png" style="margin-left: -25%"></img></td>
	    <td><p class="side" style="margin-left: -65%">Emergent behavior</td>
	  </tr>
	</table>
      </li>
            <li>
	<i><b>CRP enables "modular" behaviors; not IP</b></i>
	<p>
	  Have a look at the video demo below. Within the <i>parables</i> demo we have loaded another demo, called <i>mid point</i>, where a red dot always is maintained at the middle between two blue dots. You'll see that we <i>merge</i> their behavior into three of the shapes from the <i>parables</i> example. And viola! The shapes retain their previous behavior (swinging, etc.) yet also take on the new behavior of the <i>mid point</i> example. 
	</p>
	<table>
	  <tr>
	    <td><img src="img/26.gif" class="clicktoplay" data-staticSrc="img/26s.png" style="margin-left: -10%"></img></td>
	    <td><p class="side" style="margin-left: -25%">Modular behaviors</td>
	  </tr>
	</table>
	<p>
	  Doing this in IP is by no means easy. Where do we add this new behavior? How do we make sure the previous behaviors still work?
	</p>
      </li>
    </ul>
  </div>
    <img src="img/1.png"></img>
  <br>
  <hd1>Challenges</hd1>
  <div class="chapter">
    <p>
      The major obstacle for adopting any new programming model is often psychological rather than technical. Us programmers don't like change too much! So rather than trying to convince anybody to use CRP, we simply report that we've had quite a positive experience redoing existing demos in this framework (see the "<i>Example bin</i>" inside Sketchpad<small>14</small>). But this is just the beginning! Here are some of the many challenges that need to be addressed:
    </p>
    <ul>
      <li>
	<i><b>Performance</b></i>
	<p>
	  CRP enforces a particular way of organizing a program and its execution model follows a specific routine. With each change, the tool evaluates each constraint to compute current errors, solves the ones unsatisfied, combines the solutions, applies the final solution, and repeats the process until convergence occurs. All this machinery can be a huge overhead over a hand-coded imperative code that performs the precise set of necessary instructions to accomplish a certain task. For seamless animations, the overhead of computation is exacerbated by the fact that we might repeat the above process at a rate of 60 times per second!
	</p>
	<p>
	  Nonetheless, fortunately easy optimization opportunities were leveraged in the tool. By simply keeping track of the <i>total error</i> of the system and detecting reaching convergence (whether with acceptable or non-acceptable error value), the system draws the scene a final time and then goes idle, until the next time there is a change caused by an event, including advancement of time in temporal examples.
	</p>
	<p>
	  There are also efficiency issues associated with solving problems using any iterative approach as in relaxation, hill climbing, etc.
	</p>
      </li>
      <li>
	<i><b>Programmer burdens</b></i>
	<p>
	  To conform to the CRP model, behaviors previously accomplished by snippets of code that directly update program state must be refactored, a source of burden to most programmers. The code must be organized to produce a dictionary object of proposed patches, rather than directly manipulating the state. The system needs to also be given a <i>join</i> function to combine solutions from individual constraints.
	</p>
      </li>
      <li>
	<i><b>Choosing the appropriate granularity level for constraints</b></i>
	<p>
	  It hasn't quite come up in our short list of examples here, but the choice of how large or fine-grained constraints are organized is very important. Consider the example of solving a system of arithmetic linear equations.
	</p>
	<p>
	Clearly, setting up a separate constraint for each equation and then relying on iterative relaxation to converge the solutions from each equation is not the way to go! In that case, we have a very efficient solving tool, e.g. <i>simplex</i> method to simultaneously solve all the equations at once. What's nice is that the CRP model gives us the power to just use that: we simply create one constraint type that represents the system of equations, whose <mono>solve</mono> function will invoke a simplex solver to compute the answer.
	</p>
	<p>
	  We use this rule of thumb when designing the constraint types to be used in a program:	  
	</p>
	<center>
	  <i>Break a program into a set of logically orthogonal, <br>or only loosely related, behaviors.</i>
	</center>
	<p>
	  The objective is to reason about solving each constraint separately, and then in the  <mono>solutionJoin</mono> function worry about how conflicting solutions can be consolidated. There seems to be a loose analogy here with what's often said about <i>parallelism</i> vs. <i>concurrency</i>:
	</p>
	<p>
	  "Parallelism" is about performing independent computations in parallel for efficiency, while "concurrency" concerns ensuring these parallel computations don't get in the way of each other.
	</p>
      </li>
      <li>
	<i><b>Inadequate experiments with finite-domain constraints</b></i>
	<p>
	  As we have seen earlier, when dealing with finite-domain or integer constraints the Sketchpad/Overveld approach of <i>averaging</i> solutions to consolidate does not make sense. In our experience so far, combining solutions in these cases is not difficult. Often, the programmer has the knowledge that for a fact only one constraint will be updating a particular variable. In the case of arrays or dictionaries, we simply could combine the solutions after verifying multiple updates pertain to distinguished indices/keys and therefore compatible.
	</p>
	<p>
	  In brief, more experience is needed to evaluate if the model holds up well in general.
	  </p>
      </li>
      <li>
	<i><b>There is more! </b></i>
	<p>
	  We're blanking out here, but we're sure there are more issues. Can you point out some? 
	</p>
      </li>
      
    </ul>
    
</div>
  <img src="img/1.png"></img>
  <br>
  <p>
    Read <!--<a href="7.html">--><a>Part VII: Sketchpad<small>14</small> User Manual (coming later)</a><br>
    Back to <a href="index.html">Table of Contents</a><br>
  </p>
  <script src="./lib/click-to-play-gif.js"></script>
</body>
</html>
