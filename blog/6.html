<html>
  <title>Blog on Sketchpad14: Part VI</title>
  <head>
    <link href="./lib/prism.css" rel="stylesheet" />
    <link href="index.css" rel="stylesheet"></link>
  </head>
  </style>
<body>
  <script src="./lib/prism.js"></script>
  <hd>Half-Century Later:
    <br>
    "From Sketchpad<small>61</small> to Sketchpad<small>14</small>"
    <br>
    <small>
      Part VI: Comparison of CRP and Imperative Programming
    </small>
  </hd>
  <br><br>
  <small><a href="http://www.hesam.us">Hesam Samimi</a>, <a href="http://www.tinlizzie.org/~awarth">Alex Warth</a><br><a href="http://www.cdglabs.org">Communication Design Group</a></small>
  <br><br>
  <img src="img/1.png"></img>
  <br>
  <hd1>Advantages</hd1>
  <div class="chapter">
    <p>
      In this part we'll compare the imperative programming (IP) and constraint reactive programming (CRP) versions of a few programs, including the "Parable of the Polygons" discussed in the <a href="5.html">previous part</a>. Let's start with positives!
    </p>
    <ul>
      <li>
	<i><b>In IP behavior can be buried in piles of code; not in CRP.</b></i>
	<p>
	  IP doesn't enforce any particular restraint on programmer's thought process or organization. He is free to write any code as long as it captures the wanted behaviors. Yet the resulting code, although functional, is often cryptic and mixes behaviors in a way that's hard to parse and organize to human mind. Moreover, there is no wasy way to explore and understand the program due to lack of any per-behavior organization.
	</p>
	<p>
	  Take the <a href="http://ncase.me/polygons/play/automatic/automatic2.html">slider</a> in the <a href="http://ncase.me/polygons/">Parables of the Polygons</a> page, which is used to set the bias level of a shape. Where is the piece of code that's responsible for making such functionality?
	</p>
	<p>
	After digging into this, we see that the part of the page that includes the slider actually is embedded as an <i>iframe</i>, which loads the html file "play/automatic/automatic2.html." There we can see that there is an <i>event listener</i> setting the associated global variable representing bias to the value of the slider:
	</p>
	  <pre><code class="language-javascript">	  
	  onChange:function(values){	
	      window.BIAS = values[0];
	      // ...
	      bias_text.innerHTML = Math.round(window.BIAS*100)+"%";
	  }
	  </code></pre>
	<p>
	  Now we have identified the code responsible for this behavior. But there was no indication anywhere. Afterall, these are just lines of code like many other thousands of lines of code in this application.
	</p>
	<p>
	  The CRP model, however, would have forced the programmer to express this behavior as a constraint type. The slider behavior will indeed clearly show up in the list of constraints as an enabled behavior in the scene. In fact, as we have seen Sketchpad<small>14</small> allows to turn constraints on and off to explore the behaviors acting on the program. Here we clearly see the <mono>SliderValueConstraint</mono> in the list, can hover over the instance to see the objects it's applied to, and can temporarily disable the constraint to verify the behavior:
	</p>
	<table>
	  <tr>
	    <td><img src="img/24.gif" class="clicktoplay" data-staticSrc="img/24s.png" style="margin-left: 10%"></img></td>
	    <td><p class="side" style="margin-left: 40%">Exploring the slider behavior</td>
	  </tr>
	</table>
	<p>
	  Also note that, despite being an elaborate demo, the set of behavior types are relatively short (7-8) as we see in the graphic above. This can be contrasted to many hundreds and thousands of <i>lines of code</i> which make an imperative program.
	</p>
      </li>
      <li>
	<i><b>CRP induces a "linear" thinking process in designing, implementing, and exploring programs; IP results in "ad hoc" way of doing those.</b></i>
	<p>
	  CRP model forces the programmer to think and design the program as a set of individual behaviors. Once the set of behaviors are defined (as constraint types), building a program is simply a matter applying a selection of them to the data. Again, the list of behaviors is clearly acknowledged and alternation of behaviors can be done by selecting mixing and matching.	  
	</p>
	<p>
	  By contrast, in IP the process is quite ad-hoc. The programmer keeps a mental list of things that needs to be done for the program. She then proceeds to write the "code" that implements those things. In the lack of any organization or guidelines, this code often makes no attempt to keep the behaviors separatable and modularized. It may try to use the same "loop" construct to achieve goals A and B at the same time, etc. The lack of direction and organization can also confuse the thinking process itself, leading to bugs. Although the final outcome succeeds in achieving all desired behaviors, it too often fails to be amenable to extentions or fascialitating understanding. In CRP, extention and modifying is a matter of reshuffling set of constraints, whereas in IP often algorithms need to be reworked.
	  </p>
      </li>
      <li>
	<i><b>CRP model reduces the possibility of bugs.</b></i>
	<p>
	  In the CRP model, all constraints act on the same state in parallel, assuming each one is the only one trying to make a change. There is a separate later process that consolidates those changes into one final result. In IP, however, the same code is used to implement multiple behaviors. Therefore, each snippet of code that aims to achive a particular behavior sees a different state, as our programs run sequentially. This complicates human reasoning and increases the chance of introducing bugs.
	</p>
      </li>
      <li>
	<i><b>CRP frees the programmer from having to reason globally and computing or describing "emerging behaviors"</b></i>
	<p>
	  Have a look at the truss bridge demo shown below, an orginal Sketchpad and ThingLab demo and remade here using Sketchpad<small>14</small>. As you can see the resulting "emergant behavior" of the program is quite elaborate! There is not way to "code" the behavior of this bridge under the forces of gravity and wind imperatively. On the other hand, as you can see on the constraint listing on the right pane, the constraint types that make up this overall behavior are not complicated at all. We only had to define velocity and acceleration behaviors as well as the spring force (Hook's law). Thus the programmer only has to reason "locally" and "indivudally" about each constraint. Next, we simply had to instantiate these constraints for all the bodies and beams (springs) that make up the bridge. It is the job of the system to capture the "global" beahvior by combining the results of individual local constraints. 
	</p>
	<table>
	  <tr>
	    <td><img src="img/25.gif" class="clicktoplay" data-staticSrc="img/25s.png" style="margin-left: -25%"></img></td>
	    <td><p class="side" style="margin-left: -65%">Emergent behavior</td>
	  </tr>
	</table>
      </li>
            <li>
	<i><b>CRP enables "modular" behaviors; not IP</b></i>
	<p>
	  Have a look at the video demo below. Within the "parables" demo we have loaded another demo, called <mono>MidPoint</mono>, where a red dot always is maintained at the middle between two blue dots. You'll see that we <i>merge</i> their behavior into three of the shapes from the "parables" example. And viola! The shapes retain their previous behavior (swinging, etc.) yet also take on the new behavior of the <mono>MidPoint</mono> example. 
	</p>
	<table>
	  <tr>
	    <td><img src="img/26.gif" class="clicktoplay" data-staticSrc="img/26s.png" style="margin-left: -10%"></img></td>
	    <td><p class="side" style="margin-left: -25%">Modular behaviors</td>
	  </tr>
	</table>
	<p>
	  Doing this in IP is by no means easy. Where do we add this new behavior? How do we make sure the previous behaviors still work?
	</p>
      </li>
    </ul>
  </div>
  <img src="img/1.png"></img>
  <br>
  <p>
    Read <a href="7.html">Part VII: Sketchpad<small>14</small> User Manual</a><br>
    Back to <a href="index.html">Table of Contents</a><br>
  </p>
  <script src="./lib/click-to-play-gif.js"></script>
</body>
</html>
